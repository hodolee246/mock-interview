### 뉴스 피드 시스템 설계

정리
웹 서버는 한 사용자가 올릴 수 있는 포스팅의 수를 제한해야한다.

### 포스팅 전송(팬아웃) 서비스
어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정이다.
1. 쓰기 시점의 팬아웃
2. 읽기 시점의 팬아웃

### 쓰기 시점의 팬아웃
새로운 포스팅이 기록하는 시점에 뉴스 피드를 갱신한다. 다시 말해, 포스팅이 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록하는 것이다.
장점
 - 뉴스 피드가 실시간으로 갱신되며, 친구 목록에 있는 사용자에게 즉시 전송됨
 - 새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신됨으로 뉴시 피드를 읽는 데 시간이 짧아진다
단점
 - 핫키 문제(친구가 많으면 많을 수록 갱신하는데 많은 시간이 소요)
 - 서비스를 자주 이용하지 않는 사용자까지 피드를 갱신 해 컴퓨팅 자원이 낭비

### 읽기 시점의 팬아웃
피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다. 따라서 요청 기반 모델이며, 사용자가 본인 홈페이지나 타임라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.
장점
 - 로그인하기까지는 어떤 컴퓨팅 자원도 낭비하지 않음 (로그인 사용자만 갱신시킴)
 - 데이터를 친구 각각에 푸쉬하는 작업이 필요없어 핫키 문제도 없음
단점
 - 뉴스 피드가 많이 쌓여있을 경우 읽는데 많은 시간이 소요될 수 있다.

중요하다고 생각한 부분
포스팅 전송(팬아웃) 서비스
 - 쓰기시점
 - 읽기시점
책과 생각이 다른 부분
X
개인적인 생각
웹기준으로 읽기 시점의 팬아웃 + 쓰기시점 (향 첨가?) 느낌이 있다고 생각
 - 사용자가 직접 나 갱신할래! 하고 갱신하는 경우
 - 특정 트리거 (포스팅 작성 및 행위 시)로 갱신하는 경우
   - 포스팅 작성 시 모든 사용자에게 전달되는 핫키 문제 등 그런건 없긴함 (그래서 모호함)
### 채팅 시스템 설계
폴링
주기적으로 클라이언트가 서버에게 너 메세지 있어? 물어보는 방법
 - 자주 할 수록 서버자원 낭비
롱 폴링
 - 클라이언트는 새 메세지가 반환되거나 타임아웃 될 때까지 연결을 유지. 클라이언트는 새 메세지를 받으면 기존 연결을 종료하고
 - 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.
단점
 - 메세지를 보내는 클라이언트와 수진하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다 HTTP 서버들은 보통 무상태 서버다. 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 메세지를 받은 서버는 해당 메세지를 수신할 클라이언트와의 롤 폴링 연결을 가지고 있지 않은 서버일 수 있는 것이다.

중요하다고 생각한 부분

책과 생각이 다른 부분

개인적인 생각